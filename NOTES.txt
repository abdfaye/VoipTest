Analisis of FEC
===============

Stream corruption can be solved with 3 changes:

- Spliting the main thread (program), packet reading thread, and packet decoding threads.
- Reducing the GOP (Group Of Frames) size, increasing the number of key frames.
- Shuffling the packets to reduce the probability of loosing a group of continuous packets.

Jitter Buffer
=============

All audio and video packets are received and decoded here:

    qxmpp/src/base/QXmppRtpChannel.h:

        QXmppRtpAudioChannel::datagramReceived(const QByteArray &ba);
        QXmppRtpVideoChannel::datagramReceived(const QByteArray &ba);

'datagramReceived' is a slot that is called from here:

    qxmpp/src/client/QXmppCallManager.cpp:

        QXmppCallPrivate::createStream(const QString &media)

It starts creating an stream channel and an 'IceConnection':

        // RTP channel
        // ICE connection

And finally creates an 'IceComponent' and connects it's 'datagramReceived' signal to the channel:

        QXmppIceComponent *rtpComponent = stream->connection->component(RTP_COMPONENT);

        check = QObject::connect(rtpComponent, SIGNAL(datagramReceived(QByteArray)),
                        channelObject, SLOT(datagramReceived(QByteArray)));

'datagramReceived' is emited from here:

    src/base/QXmppStun.cpp:

        QXmppIceComponent::handleDatagram(const QByteArray &buffer, const QHostAddress &remoteHost, quint16 remotePort, QUdpSocket *socket)

Then 'handleDatagram' is called from here:

        QXmppIceComponent::readyRead()

or conected to a 'TurnAllocation' object, here:

        check = connect(m_turnAllocation, SIGNAL(datagramReceived(QByteArray,QHostAddress,quint16)),
                this, SLOT(handleDatagram(QByteArray,QHostAddress,quint16)));

in both cases, the raw datagrams are readed from an 'QUdpSocket' here:

        socket->readDatagram(buffer.data(), buffer.size(), &remoteHost, &remotePort);

throght a 'readyRead' slot here:

        QXmppTurnAllocation::readyRead()
        QXmppIceComponent::readyRead()

Knowing that, we must create a datagram reading thread, a thread for each channel, and a datagram buffer.

Media playing pipeline
=====================

For smooth Audio/Video rendering, the following scheme is recomended.

                           ________________      --------------------      ________________      --------------
                          |                |    |                    |    |                |    |              |
                         /| Audio Buffer 1 |--->| Uncompress/Convert |--->| Audio Buffer 2 |--->| Sync/Present |
     -----------------  / |________________|    |         ThPA       |    |________________|    |    ThQA      |
    | Packets Reading |/                         --------------------                            --------------
    |       ThR       |\
     -----------------  \  ________________      --------------------      ________________      --------------
                         \|                |    |                    |    |                |    |              |
                          | Video Buffer 1 |--->| Uncompress/Convert |--->| Video Buffer 2 |--->| Sync/Present |
                          |________________|    |         ThPV       |    |________________|    |    ThQV      |
                                                 --------------------                            --------------

A common rule is that ThQV is equal to the main thread. See:

https://github.com/FFmpeg/FFmpeg/blob/master/ffplay.c

Creating a Decoding Thread
==========================

'QUdpSocket' runs in the main thread but it doesn't seems to be affected at all by lightweight tasks. Also moving a socket to it's own thread seems to be troublesome.
For video streams, the most probable case is that QXmppRtpVideoChannel::readFrames() will be called from the main thread, and we aren't in control of that.
In QXmpp, based in the previous presented scheme: ThR == ThQA == ThQV == main thread, So the best we can do is to isolate ThPA and ThPV in it's own thread, that is deconding the incomming packets in a separated thread. The following packet decoding scheme is recommended:

                _______________                         ______________
     -----     |               |     -------------     |              |     -----
    | ThR |--->| Packet Buffer |--->| Decoding Th |--->| Frame Buffer |--->| ThQ |
     -----     |_______________|     -------------     |______________|     -----

A packet buffer and a decoding thread is added to QXmppRtpVideoChannelPrivate class. Since the system uses a RTP, circular buffers are recommended.
